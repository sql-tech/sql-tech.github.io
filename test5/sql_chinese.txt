=== 歡迎來到 SQL資料庫百科全書 === 「SQL資料庫百科全書」提供基礎、資料定義、進階 SQL 指令教學，包含一般、MySQL、Oracle範例，搭配表格和表結構圖，適合初學者與專業人士。我們還提供MySQL和Oracle在Windows、Linux、MacOS的安裝指南，步驟詳細，點擊左側目錄，立即開啟您的SQL學習之旅！無論是資料庫新手還是資深開發者，這裡都有您需要的知識與實務指引。

=== 資料庫安裝說明書 === 簡介 本節提供MySQL和Oracle在Windows、Linux、MacOS的安裝指南，包含步驟、模擬截圖、參數表格和注意事項，幫助您配置資料庫環境。

\--- MySQL 安裝 - Windows --- 簡介 在Windows 10/11安裝MySQL 8.0，適用64位系統。

安裝步驟

1. 下載：訪問MySQL官網，選Windows版本（\~400MB）。

---

| Download MySQL 8.0 | | \[Windows x64\] |

| \[Download Button\] |
| --- |

2. 運行：雙擊mysql-installer-web-community-8.0.x.msi，選「Developer Default」，點Next。

---

| Setup Type | | \[x\] Developer |

| \[Next Button\] |
| --- |

3. 依賴項：檢查環境（如.NET Framework），點「Execute」安裝缺少項目。
4. 配置：選「Standalone」，埠3306，點Next。

---

| Port: \[3306\] | | \[Standalone\] |

| \[Next Button\] |
| --- |

5. 密碼：設根用戶密碼（如「MySQL2025!」），點Next。
6. 安裝：點「Execute」，完成後勾選「Start MySQL」，點Finish。
7. 驗證：命令提示字元輸入mysql -u root -p，檢查mysql&gt;提示符。 mysql&gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | +--------------------+

參數

| 參數 | 值 |
| --- | --- |
| 版本 | MySQL 8.0 |
| 路徑 | C:\\Program Files\\MySQL |
| 埠 | 3306 |
| 用戶 | root |

注意

- 需2GB空間。
- 防火牆允許3306埠。
- 忘記密碼用mysqld --skip-grant-tables重設。

結構 mysql.user +------------+---------+ | user | VARCHAR | | host | VARCHAR | | password | VARCHAR | +------------+---------+

\--- MySQL 安裝 - Linux --- 簡介 在Ubuntu 22.04安裝MySQL 8.0，適用Linux發行版。

安裝步驟

1. 更新：sudo apt update && sudo apt upgrade

---

| $ sudo apt update | | \[Progress Bar\] |

| Hit:1 http://... |
| --- |

2. 安裝：sudo apt install mysql-server
3. 啟動：sudo systemctl start mysql && sudo systemctl enable mysql
4. 安全：sudo mysql_secure_installation，設密碼，移除不安全選項。

---

| Root password | | \[Input Field\] |

| \[Y/n\] Remove...? |
| --- |

5. 驗證：mysql -u root -p，檢查資料庫。 mysql&gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | +--------------------+

參數

| 參數 | 值 |
| --- | --- |
| 版本 | MySQL 8.0 |
| 路徑 | /var/lib/mysql |
| 埠 | 3306 |
| 服務 | mysql |

注意

- 需root權限。
- 檢查/etc/mysql配置。
- 允許3306埠。

結構 mysql.user +------------+---------+ | user | VARCHAR | | host | VARCHAR | | password | VARCHAR | +------------+---------+

\--- MySQL 安裝 - MacOS --- 簡介 在MacOS Ventura 13安裝MySQL 8.0，使用Homebrew。

安裝步驟

1. Homebrew：/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

---

| $ curl -fsSL ... | | \[Installing\] |

| ==&gt; Success |
| --- |

2. 安裝：brew install mysql
3. 啟動：brew services start mysql
4. 密碼：mysql_secure_installation

---

| Set password? | | \[Y/n\] \[Input\] |

| \[Continue\] |
| --- |

5. 驗證：mysql -u root -p mysql&gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | +--------------------+

參數

| 參數 | 值 |
| --- | --- |
| 版本 | MySQL 8.0 |
| 路徑 | /usr/local/Cellar/mysql |
| 埠 | 3306 |
| 服務 | mysql |

注意

- 更新Homebrew。
- 檢查/usr/local/etc/my.cnf。

結構 mysql.user +------------+---------+ | user | VARCHAR | | host | VARCHAR | | password | VARCHAR | +------------+---------+

\--- Oracle 安裝 - Windows --- 簡介 在Windows 10/11安裝Oracle 21c XE。

安裝步驟

1. 下載：訪問Oracle官網，選21c XE（\~2GB）。

---

| Oracle 21c XE | | \[Windows x64\] |

| \[Download Button\] |
| --- |

2. 解壓：解壓oracle-database-xe-21c.zip至C:\\oracle。
3. 運行：雙擊setup.exe，選路徑C:\\app\\oracle，點Next。

---

| Destination | | \[C:\\app\\oracle\] |

| \[Next Button\] |
| --- |

4. 密碼：為SYS/SYSTEM設密碼（如「Oracle2025!」），點Next。
5. 安裝：點Install，約15分鐘，自動啟動。
6. 驗證：sqlplus / as sysdba SQL&gt; SELECT \* FROM v$version; BANNER Oracle Database 21c Express Edition

參數

| 參數 | 值 |
| --- | --- |
| 版本 | Oracle 21c XE |
| 路徑 | C:\\app\\oracle |
| 埠 | 1521 |
| 服務 | XE |

注意

- 需10GB空間。
- 關閉防毒軟體。
- 檢查TNS監聽器（lsnrctl status）。

結構 dba_users +------------+---------+ | username | VARCHAR | | user_id | NUMBER | | created | DATE | +------------+---------+

\--- Oracle 安裝 - Linux --- 簡介 在Oracle Linux 8安裝Oracle 21c XE，透過RPM。

安裝步驟

1. 下載：下載oracle-database-xe-21c-1.0-1.x86_64.rpm。

---

| Oracle 21c RPM | | \[Linux x64\] |

| \[Download Button\] |
| --- |

2. 依賴：sudo dnf install -y oracle-database-preinstall-21c
3. 安裝：sudo rpm -ivh oracle-database-xe-21c-1.0-1.x86_64.rpm
4. 配置：sudo /etc/init.d/oracle-xe-21c configure

---

| SYS password | | \[Input Field\] |

| \[Continue\] |
| --- |

5. 驗證：sqlplus / as sysdba SQL&gt; SELECT \* FROM v$version; BANNER Oracle Database 21c Express Edition

參數

| 參數 | 值 |
| --- | --- |
| 版本 | Oracle 21c XE |
| 路徑 | /opt/oracle |
| 埠 | 1521 |
| 服務 | XE |

注意

- 需root權限。
- 12GB空間。
- 設ORACLE_HOME=/opt/oracle/product/21c/dbhomeXE。

結構 dba_users +------------+---------+ | username | VARCHAR | | user_id | NUMBER | | created | DATE | +------------+---------+

\--- Oracle 安裝 - MacOS --- 簡介 在MacOS Ventura 13用Docker安裝Oracle 21c XE。

安裝步驟

1. Docker：下載Docker Desktop。

---

| Docker Desktop | | \[MacOS\] \[500MB\] |

| \[Download Button\] |
| --- |

2. 啟動：打開Docker Desktop。
3. 映像：docker pull gvenzl/oracle-xe:21-slim
4. 容器：docker run -d -p 1521:1521 -e ORACLE_PASSWORD=Oracle2025 gvenzl/oracle-xe:21-slim

---

| $ docker run ... | | \[Container ID\] |

| Port 1521 |
| --- |

5. 驗證：docker exec -it \[container_id\] sqlplus sys/Oracle2025@//localhost:1521/XE as sysdba SQL&gt; SELECT \* FROM v$version; BANNER Oracle Database 21c Express Edition

參數

| 參數 | 值 |
| --- | --- |
| 版本 | Oracle 21c XE |
| 映像 | gvenzl/oracle-xe:21-slim |
| 埠 | 1521 |
| 服務 | XE |

注意

- 4GB記憶體分配。
- 檢查1521埠。
- 容器需docker start \[container_id\]重啟。

結構 dba_users +------------+---------+ | username | VARCHAR | | user_id | NUMBER | | created | DATE | +------------+---------+

=== 資料庫正規化說明書 === 簡介 資料庫正規化（Normalization）是設計資料庫的過程，透過消除冗餘資料和確保資料一致性，提升儲存效率和查詢正確性。本節詳細說明第一至第五階正規化（1NF 至 5NF），每階包含定義、規則、範例、表格和圖示，適合初學者與進階使用者。

\--- 第一階正規化（1NF） --- 定義 第一階正規化（1NF）要求表格中的每個欄位值為原子值（不可再分），且每列有唯一主鍵，無重複群組。

規則

- 每個欄位包含單一值。
- 無多值屬性或重複群組。
- 每列由主鍵唯一識別。

範例 未正規化表格：學生選課表，課程欄包含多值。

| 學生ID | 姓名 | 課程 |
| --- | --- | --- |
| 1 | 張三 | 數學,物理 |
| 2 | 李四 | 化學,生物 |

1NF 表格：拆分課程為單一行。

| 學生ID | 姓名 | 課程 |
| --- | --- | --- |
| 1 | 張三 | 數學 |
| 1 | 張三 | 物理 |
| 2 | 李四 | 化學 |
| 2 | 李四 | 生物 |

圖示 未正規化 +------------+--------+--------------+ | 學生ID | 姓名 | 課程 | +------------+--------+--------------+ | 1 | 張三 | 數學,物理 | | 2 | 李四 | 化學,生物 | +------------+--------+--------------+

1NF +------------+--------+--------+ | 學生ID | 姓名 | 課程 | +------------+--------+--------+ | 1 | 張三 | 數學 | | 1 | 張三 | 物理 | | 2 | 李四 | 化學 | | 2 | 李四 | 生物 | +------------+--------+--------+

注意

- 主鍵可為單欄（如學生ID+課程）。
- 1NF 可能增加行數，影響儲存效率，需後續正規化。

\--- 第二階正規化（2NF） --- 定義 第二階正規化（2NF）要求表格符合 1NF，且所有非主鍵欄位完全依賴主鍵（無部分依賴）。

規則

- 符合 1NF。
- 非主鍵欄位不可僅依賴主鍵的一部分（複合主鍵情況）。

範例 1NF 表格：學生選課含部分依賴。

| 學生ID | 課程ID | 姓名 | 課程名稱 |
| --- | --- | --- | --- |
| 1 | 101 | 張三 | 數學 |
| 1 | 102 | 張三 | 物理 |
| 2 | 103 | 李四 | 化學 |

問題：姓名僅依賴學生ID，課程名稱僅依賴課程ID。

2NF 表格：拆為學生表和選課表。 學生

| 學生ID | 姓名 |
| --- | --- |
| 1 | 張三 |
| 2 | 李四 |

選課

| 學生ID | 課程ID | 課程名稱 |
| --- | --- | --- |
| 1 | 101 | 數學 |
| 1 | 102 | 物理 |
| 2 | 103 | 化學 |

圖示 1NF +------------+----------+--------+------------+ | 學生ID | 課程ID | 姓名 | 課程名稱 | +------------+----------+--------+------------+ | 1 | 101 | 張三 | 數學 | | 1 | 102 | 張三 | 物理 | | 2 | 103 | 李四 | 化學 | +------------+----------+--------+------------+

2NF 學生 +------------+--------+ | 學生ID | 姓名 | +------------+--------+ | 1 | 張三 | | 2 | 李四 | +------------+--------+

選課 +------------+----------+------------+ | 學生ID | 課程ID | 課程名稱 | +------------+----------+------------+ | 1 | 101 | 數學 | | 1 | 102 | 物理 | | 2 | 103 | 化學 | +------------+----------+------------+

注意

- 僅適用複合主鍵表格。
- 減少冗餘（如姓名重複）。

\--- 第三階正規化（3NF） --- 定義 第三階正規化（3NF）要求表格符合 2NF，且非主鍵欄位無傳遞依賴（即不依賴其他非主鍵欄位）。

規則

- 符合 2NF。
- 非主鍵欄位直接依賴主鍵。

範例 2NF 表格：選課表含傳遞依賴。

| 學生ID | 課程ID | 課程名稱 | 教師 |
| --- | --- | --- | --- |
| 1 | 101 | 數學 | 王老師 |
| 1 | 102 | 物理 | 陳老師 |

問題：教師依賴課程名稱，非主鍵（學生ID+課程ID）。

3NF 表格：拆為選課表和課程表。 選課

| 學生ID | 課程ID |
| --- | --- |
| 1 | 101 |
| 1 | 102 |

課程

| 課程ID | 課程名稱 | 教師 |
| --- | --- | --- |
| 101 | 數學 | 王老師 |
| 102 | 物理 | 陳老師 |

圖示 2NF +------------+----------+------------+----------+ | 學生ID | 課程ID | 課程名稱 | 教師 | +------------+----------+------------+----------+ | 1 | 101 | 數學 | 王老師 | | 1 | 102 | 物理 | 陳老師 | +------------+----------+------------+----------+

3NF 選課 +------------+----------+ | 學生ID | 課程ID | +------------+----------+ | 1 | 101 | | 1 | 102 | +------------+----------+

課程 +----------+------------+----------+ | 課程ID | 課程名稱 | 教師 | +----------+------------+----------+ | 101 | 數學 | 王老師 | | 102 | 物理 | 陳老師 | +----------+------------+----------+

注意

- 3NF 減少更新異常。
- 實務中多止於 3NF。

\--- 第四階正規化（4NF） --- 定義 第四階正規化（4NF）要求表格符合 3NF，且無多值依賴（非主鍵欄位間獨立）。

規則

- 符合 3NF。
- 消除非平凡多值依賴。

範例 3NF 表格：學生興趣和課程多值依賴。

| 學生ID | 興趣 | 課程 |
| --- | --- | --- |
| 1 | 音樂 | 數學 |
| 1 | 音樂 | 物理 |
| 1 | 運動 | 數學 |
| 1 | 運動 | 物理 |

問題：興趣和課程獨立於學生ID，需拆分。

4NF 表格：分為學生興趣表和學生課程表。 學生興趣

| 學生ID | 興趣 |
| --- | --- |
| 1 | 音樂 |
| 1 | 運動 |

學生課程

| 學生ID | 課程 |
| --- | --- |
| 1 | 數學 |
| 1 | 物理 |

圖示 3NF +------------+--------+--------+ | 學生ID | 興趣 | 課程 | +------------+--------+--------+ | 1 | 音樂 | 數學 | | 1 | 音樂 | 物理 | | 1 | 運動 | 數學 | | 1 | 運動 | 物理 | +------------+--------+--------+

4NF 學生興趣 +------------+--------+ | 學生ID | 興趣 | +------------+--------+ | 1 | 音樂 | | 1 | 運動 | +------------+--------+

學生課程 +------------+--------+ | 學生ID | 課程 | +------------+--------+ | 1 | 數學 | | 1 | 物理 | +------------+--------+

注意

- 4NF 罕用，僅在複雜多值關係時應用。
- 拆分可能增加查詢複雜度。

\--- 第五階正規化（5NF） --- 定義 第五階正規化（5NF）要求表格符合 4NF，且無聯接依賴（不可透過較小表格聯接重構）。

規則

- 符合 4NF。
- 表格分解後，聯接不產生偽資料。

範例 4NF 表格：代理商、產品、公司關係。

| 代理商 | 產品 | 公司 |
| --- | --- | --- |
| A1 | P1 | C1 |
| A1 | P2 | C1 |
| A2 | P1 | C2 |

問題：聯接依賴導致分解後需三表。

5NF 表格：拆為代理商-產品、產品-公司、代理商-公司。 代理商-產品

| 代理商 | 產品 |
| --- | --- |
| A1 | P1 |
| A1 | P2 |
| A2 | P1 |

產品-公司

| 產品 | 公司 |
| --- | --- |
| P1 | C1 |
| P2 | C1 |
| P1 | C2 |

代理商-公司

| 代理商 | 公司 |
| --- | --- |
| A1 | C1 |
| A2 | C2 |

圖示 4NF +----------+--------+--------+ | 代理商 | 產品 | 公司 | +----------+--------+--------+ | A1 | P1 | C1 | | A1 | P2 | C1 | | A2 | P1 | C2 | +----------+--------+--------+

5NF 代理商-產品 +----------+--------+ | 代理商 | 產品 | +----------+--------+ | A1 | P1 | | A1 | P2 | | A2 | P1 | +----------+--------+

產品-公司 +--------+--------+ | 產品 | 公司 | +--------+--------+ | P1 | C1 | | P2 | C1 | | P1 | C2 | +--------+--------+

代理商-公司 +----------+--------+ | 代理商 | 公司 | +----------+--------+ | A1 | C1 | | A2 | C2 | +----------+--------+

注意

- 5NF 極少使用，僅在高度複雜關係時必要。
- 需權衡查詢性能。

=== 資料庫效能提升標準作業流程 === 簡介 資料庫效能提升是確保快速查詢和穩定運行的關鍵。本節針對 MySQL 和 Oracle，介紹三種方法：資料庫配置優化、正規化調整、SQL 語法優化。每部分包含詳細步驟、範例、表格和圖示，幫助您提升效能。

\--- MySQL 配置優化 --- 簡介 透過調整 MySQL 配置參數，提升查詢速度和資源利用率，適用於高流量應用。

步驟

1. 檢查硬體：確認 CPU、記憶體（建議 16GB+）、SSD。
2. 調整緩衝區：編輯 /etc/my.cnf，設置 innodb_buffer_pool_size 為記憶體的 60%-70%。 \[mysqld\] innodb_buffer_pool_size=4G

=== SQL DROP TABLE - 刪除資料表 === 語法 DROP TABLE 刪除資料表。 DROP TABLE table_name;

範例 一般 刪除員工表。 DROP TABLE employees;

| 表 | 操作 |
| --- | --- |
| employees | 已刪除 |

MySQL 刪除表，若存在。 DROP TABLE IF EXISTS departments;

| 表 | 操作 |
| --- | --- |
| departments | 已刪除 |

Oracle 刪除表並清除回收站。 DROP TABLE orders PURGE;

| 表 | 操作 |
| --- | --- |
| orders | 已刪除 |

結構 \[表已刪除\]

=== SQL TRUNCATE TABLE - 清空資料表 === 語法 TRUNCATE TABLE 清空資料表資料。 TRUNCATE TABLE table_name;

範例 一般 清空員工表資料。 TRUNCATE TABLE employees;

| 表 | 操作 |
| --- | --- |
| employees | 已清空 |

MySQL 清空訂單表。 TRUNCATE TABLE orders;

| 表 | 操作 |
| --- | --- |
| orders | 已清空 |

Oracle 清空產品表並重用空間。 TRUNCATE TABLE products REUSE STORAGE;

| 表 | 操作 |
| --- | --- |
| products | 已清空 |

結構 employees +-------+-------+ | id | INT | | name | VARCHAR | +-------+-------+ \[資料已清空\]

=== SQL USE - 選擇資料庫 === 語法 USE 選擇要操作的資料庫（主要用於 MySQL）。 USE database_name;

範例 一般 選擇公司資料庫（通用語法依賴資料庫系統）。 USE company_db;

| 資料庫 | 操作 |
| --- | --- |
| company_db | 已選擇 |

MySQL 選擇員工資料庫。 USE employee_db;

| 資料庫 | 操作 |
| --- | --- |
| employee_db | 已選擇 |

Oracle Oracle 使用模式切換（非 USE 語法）。 ALTER SESSION SET CURRENT_SCHEMA = hr;

| 模式 | 操作 |
| --- | --- |
| hr | 已選擇 |

結構 \[資料庫已選擇\]

=== SQL INSERT INTO - 插入資料 === 語法 INSERT INTO 插入新記錄。 INSERT INTO table_name (column1, column2) VALUES (value1, value2);

範例 一般 插入員工記錄。 INSERT INTO employees (id, name, salary) VALUES (1, '張三', 50000);

| id | name | salary |
| --- | --- | --- |
| 1 | 張三 | 50000.00 |

MySQL 插入多筆記錄。 INSERT INTO employees (id, name, salary) VALUES (2, '李四', 55000), (3, '王五', 60000);

| id | name | salary |
| --- | --- | --- |
| 2 | 李四 | 55000.00 |
| 3 | 王五 | 60000.00 |

Oracle 使用序列插入。 INSERT INTO employees (id, name, salary) VALUES (emp_seq.NEXTVAL, '趙六', 65000);

| id | name | salary |
| --- | --- | --- |
| 4 | 趙六 | 65000.00 |

結構 employees +-------+---------+ | id | INT | | name | VARCHAR | | salary| DECIMAL | +-------+---------+

=== SQL UPDATE - 更新資料 === 語法 UPDATE 更新資料表記錄。 UPDATE table_name SET column1 = value1 WHERE condition;

範例 一般 更新員工薪資。 UPDATE employees SET salary = 60000 WHERE id = 1;

| id | salary |
| --- | --- |
| 1 | 60000.00 |

MySQL 更新多列。 UPDATE employees SET salary = 65000, department = 'IT' WHERE id = 2;

| id | salary | department |
| --- | --- | --- |
| 2 | 65000.00 | IT |

Oracle 更新符合條件的記錄。 UPDATE employees SET salary = 70000 WHERE department = 'HR';

| department | salary |
| --- | --- |
| HR | 70000.00 |

結構 employees +------------+---------+ | id | INT | | salary | DECIMAL | | department | VARCHAR | +------------+---------+

=== SQL DELETE FROM - 刪除資料 === 語法 DELETE FROM 刪除資料表記錄。 DELETE FROM table_name WHERE condition;

範例 一般 刪除特定員工。 DELETE FROM employees WHERE id = 1;

| id | 操作 |
| --- | --- |
| 1 | 已刪除 |

MySQL 刪除部門員工。 DELETE FROM employees WHERE department = 'HR';

| department | 操作 |
| --- | --- |
| HR | 已刪除 |

Oracle 刪除舊訂單。 DELETE FROM orders WHERE order_date &lt; TO_DATE('2023-01-01', 'YYYY-MM-DD');

| 條件 | 操作 |
| --- | --- |
| order_date &lt; 2023-01-01 | 已刪除 |

結構 employees +------------+---------+ | id | INT | | department | VARCHAR | +------------+---------+

=== 進階 SQL ===

=== SQL UNION - 合併查詢結果 === 語法 UNION 合併查詢結果，去重複。 SELECT column1 FROM table1 UNION SELECT column1 FROM table2;

## 範例 一般 合併員工和客戶姓名。 SELECT name FROM employees UNION SELECT name FROM customers; name

張三 李四

## MySQL 合併部門員工，排序。 SELECT name FROM employees WHERE dept = 'HR' UNION SELECT name FROM employees WHERE dept = 'IT' ORDER BY name; name

陳七 王五

## Oracle 合併訂單產品ID。 SELECT prod_id FROM orders UNION SELECT prod_id FROM order_history; prod_id

1001 1002

結構 orders +---------+-------+ | prod_id | NUMBER| | date | DATE | +---------+-------+

=== SQL UNION ALL - 合併查詢結果（含重複） === 語法 UNION ALL 合併查詢結果，保留重複。 SELECT column1 FROM table1 UNION ALL SELECT column1 FROM table2;

## 範例 一般 合併員工和客戶姓名，含重複。 SELECT name FROM employees UNION ALL SELECT name FROM customers; name

張三 張三

## MySQL 合併部門員工，含重複。 SELECT name FROM employees WHERE dept = 'HR' UNION ALL SELECT name FROM employees WHERE dept = 'IT'; name

張三 王五

## Oracle 合併訂單產品ID，含重複。 SELECT prod_id FROM orders UNION ALL SELECT prod_id FROM order_history; prod_id

1001 1001

結構 orders +---------+-------+ | prod_id | NUMBER| | date | DATE | +---------+-------+

=== SQL 內嵌視觀表 - 子查詢作為視圖 === 語法 內嵌視觀表（子查詢）用於 FROM 子句中作為臨時表。 SELECT column FROM (SELECT column FROM table) AS subview;

範例 一般 從高薪員工子查詢中選擇資料。 SELECT name, salary FROM (SELECT name, salary FROM employees WHERE salary &gt; 50000) AS high_salary;

| name | salary |
| --- | --- |
| 張三 | 60000.00 |

MySQL 使用內嵌視圖查詢部門人數。 SELECT dept, count FROM (SELECT department AS dept, COUNT(\*) AS count FROM employees GROUP BY department) AS dept_counts WHERE count &gt; 5;

| dept | count |
| --- | --- |
| IT | 10 |

Oracle 從訂單總額子查詢中選擇資料。 SELECT order_id, total FROM (SELECT order_id, SUM(amount) AS total FROM order_details GROUP BY order_id) WHERE total &gt; 1000;

| order_id | total |
| --- | --- |
| 101 | 3000.00 |

結構 high_salary +-------+---------+ | name | VARCHAR | | salary| DECIMAL | +-------+---------+

=== SQL INTERSECT - 交集結果 === 語法 INTERSECT 返回多個查詢的交集（支援於 Oracle）。 SELECT column1 FROM table1 INTERSECT SELECT column1 FROM table2;

## 範例 一般 查找員工和客戶共有的姓名（通用語法依賴資料庫）。 SELECT name FROM employees INTERSECT SELECT name FROM customers; name

張三

## MySQL MySQL 不支援 INTERSECT，可用 JOIN 模擬。 SELECT DISTINCT e.name FROM employees e INNER JOIN customers c ON e.name = c.name; name

張三

## Oracle 查找共有的產品ID。 SELECT prod_id FROM orders INTERSECT SELECT prod_id FROM order_history; prod_id

1001

結構 orders +---------+-------+ | prod_id | NUMBER| | date | DATE | +---------+-------+

=== SQL MINUS - 差集結果 === 語法 MINUS 返回第一個查詢有但第二個查詢沒有的結果（支援於 Oracle）。 SELECT column1 FROM table1 MINUS SELECT column1 FROM table2;

## 範例 一般 查找僅在員工表而不在客戶表的姓名（通用語法依賴資料庫）。 SELECT name FROM employees MINUS SELECT name FROM customers; name

李四

## MySQL MySQL 不支援 MINUS，可用 LEFT JOIN 模擬。 SELECT DISTINCT e.name FROM employees e LEFT JOIN customers c ON e.name = c.name WHERE c.name IS NULL; name

李四

## Oracle 查找僅在訂單表中的產品ID。 SELECT prod_id FROM orders MINUS SELECT prod_id FROM order_history; prod_id

1002

結構 orders +---------+-------+ | prod_id | NUMBER| | date | DATE | +---------+-------+

=== SQL LIMIT - 限制結果筆數 === 語法 LIMIT 限制查詢返回的筆數（支援於 MySQL）。 SELECT column FROM table LIMIT number;

## 範例 一般 查詢前5名員工（通用語法依賴資料庫）。 SELECT name FROM employees LIMIT 5; name

張三 李四

MySQL 查詢前5筆高薪員工。 SELECT name, salary FROM employees ORDER BY salary DESC LIMIT 5;

| name | salary |
| --- | --- |
| 趙六 | 60000.00 |

## Oracle Oracle 使用 FETCH FIRST 模擬 LIMIT。 SELECT name FROM employees FETCH FIRST 5 ROWS ONLY; name

張三

結構 employees +-------+---------+ | name | VARCHAR | | salary| DECIMAL | +-------+---------+

=== SQL 子查詢 - 嵌套查詢 === 語法 子查詢嵌套在主查詢中，用於 WHERE 或 FROM 子句。 SELECT column FROM table WHERE column = (SELECT column FROM table WHERE condition);

範例 一般 查找薪資高於平均的員工。 SELECT name, salary FROM employees WHERE salary &gt; (SELECT AVG(salary) FROM employees);

| name | salary |
| --- | --- |
| 張三 | 60000.00 |

MySQL 查找部門最高薪資的員工。 SELECT name, salary FROM employees WHERE salary = (SELECT MAX(salary) FROM employees WHERE department = 'IT');

| name | salary |
| --- | --- |
| 趙六 | 60000.00 |

## Oracle 查找有訂單的客戶。 SELECT name FROM customers WHERE id IN (SELECT cust_id FROM orders); name

林八

結構 employees +-------+---------+ | name | VARCHAR | | salary| DECIMAL | +-------+---------+

=== SQL WITH - 通用表達式（CTE） === 語法 WITH 定義通用表達式（CTE），簡化複雜查詢。 WITH cte_name AS (SELECT column FROM table) SELECT \* FROM cte_name;

範例 一般 使用 CTE 查詢高薪員工。 WITH high_salary AS (SELECT name, salary FROM employees WHERE salary &gt; 50000) SELECT name, salary FROM high_salary;

| name | salary |
| --- | --- |
| 張三 | 60000.00 |

MySQL 使用 CTE 查詢部門人數。 WITH dept_counts AS (SELECT department, COUNT(\*) AS count FROM employees GROUP BY department) SELECT department, count FROM dept_counts WHERE count &gt; 5;

| department | count |
| --- | --- |
| IT | 10 |

Oracle 使用 CTE 查詢訂單總額。 WITH order_totals AS (SELECT order_id, SUM(amount) AS total FROM order_details GROUP BY order_id) SELECT order_id, total FROM order_totals WHERE total &gt; 1000;

| order_id | total |
| --- | --- |
| 101 | 3000.00 |

結構 high_salary +-------+---------+ | name | VARCHAR | | salary| DECIMAL | +-------+---------+

=== SQL EXISTS - 檢查子查詢存在 === 語法 EXISTS 檢查子查詢是否返回結果。 SELECT column FROM table WHERE EXISTS (SELECT 1 FROM table2 WHERE condition);

## 範例 一般 查找有訂單的客戶。 SELECT name FROM customers WHERE EXISTS (SELECT 1 FROM orders WHERE orders.cust_id = customers.id); name

林八

## MySQL 查找有高薪員工的部門。 SELECT department FROM employees e1 WHERE EXISTS (SELECT 1 FROM employees e2 WHERE e2.department = e1.department AND e2.salary &gt; 50000); department

IT

## Oracle 查找有歷史訂單的產品。 SELECT prod_name FROM products p WHERE EXISTS (SELECT 1 FROM order_history oh WHERE oh.prod_id = p.prod_id); prod_name

Apple

結構 customers +-------+---------+ | id | INT | | name | VARCHAR | +-------+---------+

=== SQL CASE - 條件表達式 === 語法 CASE 提供條件邏輯，返回不同值。 SELECT CASE WHEN condition THEN result1 ELSE result2 END AS column FROM table;

範例 一般 根據薪資分級員工。 SELECT name, CASE WHEN salary &gt; 60000 THEN '高薪' WHEN salary &gt; 40000 THEN '中薪' ELSE '低薪' END AS salary_level FROM employees;

| name | salary_level |
| --- | --- |
| 張三 | 高薪 |

MySQL 根據部門分類。 SELECT name, CASE department WHEN 'IT' THEN '技術部' WHEN 'HR' THEN '人力部' ELSE '其他' END AS dept_type FROM employees;

| name | dept_type |
| --- | --- |
| 趙六 | 技術部 |

Oracle 根據訂單金額分級。 SELECT order_id, CASE WHEN amount &gt; 5000 THEN '大訂單' ELSE '小訂單' END AS order_size FROM orders;

| order_id | order_size |
| --- | --- |
| 101 | 小訂單 |

結構 employees +------------+---------+ | name | VARCHAR | | salary | DECIMAL | | department | VARCHAR | +------------+---------+

=== SQL 窗口函數 - 進階分析 === 語法 窗口函數在指定範圍內計算，如排名、累積總計等。 SELECT column, FUNCTION() OVER (PARTITION BY column ORDER BY column) FROM table;

範例 一般 按部門計算薪資排名。 SELECT name, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank FROM employees;

| name | salary | rank |
| --- | --- | --- |
| 趙六 | 60000.00 | 1 |

MySQL 計算部門累積薪資（MySQL 8.0+ 支援）。 SELECT name, salary, SUM(salary) OVER (PARTITION BY department ORDER BY salary) AS cumulative_salary FROM employees;

| name | salary | cumulative_salary |
| --- | --- | --- |
| 趙六 | 60000.00 | 60000.00 |

Oracle 按年份計算訂單總額排名。 SELECT TO_CHAR(order_date, 'YYYY') AS year, SUM(amount) AS total, RANK() OVER (ORDER BY SUM(amount) DESC) AS rank FROM orders GROUP BY TO_CHAR(order_date, 'YYYY');

| year | total | rank |
| --- | --- | --- |
| 2023 | 50000.00 | 1 |

結構 employees +------------+---------+ | name | VARCHAR | | salary | DECIMAL | | department | VARCHAR | +------------+---------+

=== SQL 窗口函數 - 進階分析 === 語法 窗口函數在指定範圍內計算，如排名、累積總計等。 SELECT column, FUNCTION() OVER (PARTITION BY column